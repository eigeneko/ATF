#!/usr/bin/python3 
import argparse
import os

class PredicateLogicConvert:

    def __init__(self):
        home='/home/eigeneko/hanabi'
        self.conf = os.path.join(home, 'Def_group')
        self.formulaSet = []
        self.readSymbol()

    def readSymbol(self):
        self.defDict = {}
        with open(self.conf, 'rt') as f:
            for line in f:
                if not x or line[0] in ['#', '-']:
                    continue
                x = line.split()
                fecLanguage = x[1]
                logicLanguage = x[0]
                self.defDict[fecLanguage] = logicLanguage

    def convert(self, inputFile, withEOQ):
        self.inputFile = inputFile
        if withEOQ == True:
            # Generating polish with EOQ first.
            self.polishOut = inputFile + "_polish_withEOQ"
            self.polishConvert(withEOQ=True)
        self.polishOut = inputFile + "_polish"
        self.infixOut  = inputFile + "_infix"
        self.fecTranslate()
        self.fecConvert()

    # Translate FreeEnCal language to normal logical symbol
    def fecTranslate(self, withEOQ=False):
        '''withEOQ 表示转换后是否保留EOQ，默认为false，转换后不会保留'''
        with open(self.inputFile, 'rt') as f:
            out = open(self.polishOut, 'wt')
            for line in f:                
                if line.startswith('#'):
                    out.write(line)
                    self.formulaSet.append(line)
                    continue

                formula = line.split(',')
                for index, value in enumerate(formula):
                    if value in self.defDict.keys():
                        formula[index] = self.defDict[value]
                    if value == "EOQ" and not withEOQ:
                        del formula[index]
                out.write(''.join(formula)) 
                self.formulaSet.append(formula)
            out.close()

    # 对于一个FreeEnCal的输出文件进行转换，注意Degree部分是不需要转换的
    
    def fecConvert(self):
        
        diction = ['#', 'InferenceRule', 'LogicalPremise', 'Degree', 'EliminationRule', 'EmpiricalPremise']
        nochange = False
        with open(self.polishOut, 'rt') as f:
            out = open(self.infixOut, 'wt')
            for line in f:
                symbols = [e for e in line.split()]
                if nochange == True or symbols[0] in diction:                
                    if symbols[0] == 'Degree':
                        nochange = True
                    if symbols[0] == 'EliminationRule':
                        nochange = False
                    out.write(line)

                else:
                    stack   = []
                    while symbols:
                        
                        cur = symbols[-1]
                        print("stack:", stack)
                        print("cur:", cur)
                        # Connectors
                        if cur in ["⇒", "∧"]:
                            stack.append("(" + stack.pop() + symbols.pop() + stack.pop() + ")")

                        elif cur == "￢":
                            stack.append("(" + symbols.pop() + stack.pop() + ")") 
                        
                        # Functions
                        elif cur in ['×', '∩', '∪', '+', 'notsub', '"', '◦', "'", '•']:
                            stack.append("(" + stack.pop() + symbols.pop() + stack.pop() + ")")

                        elif cur in ['{x}', 'rotate(x)', 'flip(x)', 'D(x)', 'inverse(x)', 'succ(x)', 'diag(x)', 'U(x)', 'P(x)', 
                                     'cantor(x)', 'regular(x)', 'memb(x)', 'sv1(x)', 'sv2(x)', 'sv3(x)', 'G(x)']:
                            stack.append(symbols.pop().replace('x', stack.pop()))
                        
                        elif cur == 'R(z)':
                            stack.append(symbols.pop().replace('z', stack.pop()))
                        
                        elif cur in ['~', '1st', '2nd']:
                            stack.append("(" + symbols.pop() + stack.pop() + ")") 
                        
                        elif cur == '{x,x}':
                            symbols.pop()
                            stack.append('{' + stack.pop() + ',' + stack.pop() + '}')

                        elif cur == '<x,y>':
                            stack.append(symbols.pop().replace('x', stack.pop()).replace('y', stack.pop()))

                        elif cur == 'restrict(xr,x,y)':
                            stack.append(symbols.pop().replace('xr', stack.pop()).replace('x', stack.pop()).replace('y', stack.pop()))

                        elif cur == 'nothom1(xh,xf,xg)':
                            stack.append(symbols.pop().replace('xh', stack.pop()).replace('xf', stack.pop()).replace('xg', stack.pop()))
                            
                        elif cur == 'nothom2(xh,xf,sxg)':
                            stack.append(symbols.pop().replace('xh', stack.pop()).replace('xf', stack.pop()).replace('xg', stack.pop()))
                            
                        elif cur in ['dom(z,x,y)', 'ran(z,x,y)']:
                            stack.append(symbols.pop().replace('z', stack.pop()).replace('x', stack.pop()).replace('y', stack.pop()))
                            
                             
                        # Predicate 
                        # ∈放在这里,只能处理a∈b的情况,(a•b)∈G 会出错,
                        elif cur in ['⊆', '=']:
                            try:
                                stack.append("(" + stack.pop() + symbols.pop() + stack.pop() + ")")
                            except Exception as e:
                                print(e)

                        elif cur in ['INDUCTIVE(x)', 'SINGVAL(x)', 'FUNCTION(x)', 'ONEONE(x)', 'OPERATION']:
                            stack.append(symbols.pop().replace('x', stack.pop()))

                        elif cur in ['COMPATIBLE(x,y,z)', 'HOM(x,y,z)']:
                            stack.append(symbols.pop().replace('x', stack.pop()).replace('y', stack.pop()).replace('z', stack.pop()))
        
                        # Variables
                        # Leave out brackets for ∀
                        elif cur in ['∀x' , '∀y', '∀u', '∀z', '∃x', '∃y', '∃u', '∃z'] or cur in ['∀a', '∀b', '∀c', '∀d', '∃a', '∃b', '∃c', '∃d', '∃e']:
                            try:
                                stack.append(symbols.pop() + stack.pop())
                            except Exception:
                                print(line)

                        else:
                            stack.append(symbols.pop())

                    out.write(" ".join(stack)+'\n')
                    out.close()        

            
if __name__ == "__main__":
    
    parser = argparse.ArgumentParser(description='FreeEnCal Logic Fragments Convert')

    parser.add_argument(dest='file', metavar='file', nargs=1, help='Input the name of file you want to format')
    args = parser.parse_args()
    filename = args.file[0]

    PLC = PredicateLogicConvert()
    PLC.convert(inputFile=filename, withEOQ=True)